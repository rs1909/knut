\documentclass[10pt,a4paper]{ddedoc}

\usepackage{graphicx}
\usepackage{amsmath,amssymb}
\usepackage{url}
\usepackage{listings}

\pagestyle{plain}

\textwidth=6.25in
\textheight=9.5in
\hoffset=-0.6in
\voffset=-0.8in

\input{macros}

\def\pdde{{P\kern-.15emD\kern-.15emD\kern-.15emE\raisebox{.25ex}{-}C\kern-.1emO\kern-.1emN\kern-.05emT}}


\def\iconAdd{\includegraphics[scale=0.5]{fig/r22-action-add.eps}}
\def\iconEraser{\includegraphics[scale=0.5]{fig/cr22-action-eraser.eps}}
\def\iconPrint{\includegraphics[scale=0.5]{fig/cr22-action-fileprint.eps}}
\def\iconRun{\includegraphics[scale=0.5]{fig/cr22-action-launch.eps}}
\def\iconStop{\includegraphics[scale=0.5]{fig/cr22-action-stop.eps}}
\def\iconBuild{\includegraphics[scale=0.5]{fig/cr22-action-build.eps}}
\def\iconExit{\includegraphics[scale=0.5]{fig/cr22-action-exit.eps}}
\def\iconSaveAs{\includegraphics[scale=0.5]{fig/cr22-action-filesaveas.eps}}
\def\iconPencil{\includegraphics[scale=0.5]{fig/cr22-action-pencil.eps}}
\def\iconText{\includegraphics[scale=0.5]{fig/cr22-action-view_text.eps}}
\def\iconColorize{\includegraphics[scale=0.5]{fig/cr22-action-colorize.eps}}
\def\iconOpen{\includegraphics[scale=0.5]{fig/cr22-action-fileopen.eps}}
\def\iconSave{\includegraphics[scale=0.5]{fig/cr22-action-filesave.eps}}
\def\iconRemove{\includegraphics[scale=0.5]{fig/cr22-action-remove.eps}}
\def\iconPdf{\includegraphics[scale=0.5]{fig/cr22-mime-pdf.eps}}

\begin{document}
\lstset{language=C++,tabsize=3,columns=flexible,breaklines=true,escapechar=\%}
\makeatother
%
\title{\pdde{}}
\subtitle{A continuation and bifurcation software for delay-differential
equations}
\author{R\'obert Szalai}
\newcommand{\pddever}{1.1.1}
\version{\pddever}
\date{9 October 2006}
\maketitle

\begin{center}
{\bf \large Revision history } \vskip 0.25em
  \begin{tabular}{ |l|c|l| }
    \hline Date & Version & Institution \\
    \hline Sept.\ 2002 -- Jan.\ 2004 & & Budapest University of Technology and
Economics \\
    \hline Febr.\ 2004 -- July 2004 & & University of Bristol \\
    \hline Sept.\ 2004 -- June 2005 & 0.9.2 -- 0.9.8 & Massachusetts Institute
of Technology \\
    \hline July 2005 -- Sept. 2005 & 0.9.9 -- 0.9.17 & N.A. \\
    \hline Sept. 2005 -- Apr. 2006 & 0.9.18 -- 1.0.3 & Budapest University of
Technology and Economics \\
    \hline May 2006 -- & 1.0.4 -- & University of Bristol \\
    \hline
  \end{tabular}
\end{center}

\vskip 3em
\hrule
\vskip 2em
\begin{center} {\bf \large Trademarks } \vskip 0.25em \end{center}
The product names used in this manual are for identification purposes only. All
trademarks and registered trademarks are the property of their respective
owners.

\newpage

\tableofcontents

\newpage

\section{Introduction}

The software can analyze periodic orbits of delay-differential equations in the
general form
\begin{equation}
	\dot{x}(t) = f (t, x(t-\tau_0), x(t - \tau_1), \dots , x(t - \tau_r), \lambda
), \label{gensys}
\end{equation}
where $f$ can be either periodic in $t$ or independent of $t$, which is called
the autonomous case. The right hand side of (\ref{gensys}) and the delays
($\tau_i : \mathbb{R}^p \to [0,h)$ with $h<\infty$) smoothly depend on the
parameter vector $\lambda \in \mathbb{R}^p$. The solution $x(t)$ is assumed to
be an $\mathbb{R}^n$ valued continuous function satisfying the periodicity
condition
\[
	x(t) = x(t+T),\quad t \in \mathbb{R}.
\]
Because of periodicity, the software is tracking a function segment $\varphi \in
C([0,T],\mathbb{R}^n)$ only. The solution segment $\varphi$ is approximated by
piecewise polynomials \cite{engcol,engstab}.

The software can continue periodic orbits of (\ref{gensys}) along one scalar
parameter. It can determine the stability of a periodic orbit by computing
finitely many Floquet multipliers of the largest magnitude. Codimension-one
bifurcations are detected along the solution branch using the Floquet
multipliers, and bifurcation points can be calculated using test-functionals.
When a branching point of periodic orbits is encountered the software can be
directed to continue the other branch. Similarly, when a period-doubling
bifurcation point is found, the period-two branch can be selected for
continuation.

The three generic codimension-one bifurcations (Neimark-Sacker, period doubling
and fold) can be continued along two parameters. The defining systems of these
bifurcations are minimally extended and use test-functionals. Moreover, a
limited number of codimension-two bifurcations can be continued, when two
different test-functionals are selected.

Fixed points of autonomous systems can also be continued as constant periodic
orbits with fixed period. In this case the Hopf bifurcation is detected as
Neimark-Sacker bifurcation, and the periodic solution, emanating from the Hopf
point, can be continued by switching to the periodic solution branch.
Although, continuing fixed points in this way is very inefficient, it might help
in avoiding the hassle of producing starting points using some other numerical
package like DDE-BIFTOOL \cite{DDEBIF} or by simulation.

\section{Installation}

It is recommended to install the software from the source. This requires several freely
available development tools. For Microsoft Windows there is a self-extracting installer
available as well.

\subsection{Requirements of compiling the software}

For building and configuring the software the CMake\footnote{\url{http://www.cmake.org}}
utility is used. It is available for various operating systems. For compiling 
the software the GNU GCC C++ compiler\footnote{\url{http://gcc.gnu.org}} starting with 
version 3.3.6 is recommended.

The package uses the ATLAS\footnote{\url{http://math-atlas.sourceforge.net}}
basic linear algebra software library for matrix-vector operations. This library can be
tuned for the target processor, which takes a substantial amount of time.
To avoid the lengthy compilation it is possible to download
pre-compiled versions, which contain the necessary files (\filef{libatlas.a} and
\filef{libcblas.a}). When configuring the software CMake looks for these two files
in the \filef{ATLAS/lib} subdirectory of the source tree, \filef{/usr/lib}, \filef{/usr/lib/atlas} 
and some additional directories in this order.

The (optional) graphical user interface requires the Qt\footnote{\url{www.trolltech.com}} 
toolkit (version 4.2). CMake looks for the \filef{qmake} utility to find the Qt
installation, so make sure that \filef{qmake} is in your \filef{\$PATH}.

On Unix and Linux systems the \filef{pcompile} script uses
the \filef{sed} command, which is necessary to compile system definition files.

\subsection{Linux and Unix}

The software comes in a compressed source archive form
\filef{pdde-cont-{\pddever}.tar.bz2}, so it has to be uncompressed first into a
convenient directory using the following command:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\ttfamily,frame=single]
$ bzip2 -d pdde-cont-%\@version%.tar.bz2
$ tar xvf pdde-cont-%\@version%.tar
\end{lstlisting} \end{quote} } \noindent
The second step is to copy the compiled ATLAS library files (\filef{libatlas.a}
and \filef{libcblas.a}) into the
\filef{pdde-cont-\@version/ATLAS/lib} subdirectory.

Now the package is ready for the automatic configuration:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ cd pdde-cont-%\@version%
$ ./build-unix.sh
\end{lstlisting} \end{quote} } \noindent
This configures and builds software after which it installs into the
\filef{pdde-cont/} folder in the user's home directory.
In order to make the software work, the \filef{PATH} environment variable has
to be set up. In the case of the \filef{bash} shell include the
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
export PATH=$PATH:$HOME/pdde-cont/bin
\end{lstlisting} \end{quote} } \noindent
line into the \filef{.bash\_profile} configuration file in your \filef{HOME}
directory. For the C shell (\filef{csh}) insert the following line
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
setenv PATH $PATH:$HOME/pdde-cont/bin
\end{lstlisting} \end{quote} } \noindent
into \filef{.cshrc}. To activate the changes log out and log in again.

\subsection{Windows}

The simplest way of installing the software is to run the
\filef{pdde-cont-{\pddever}.exe}, which will extract the package into a
preferred directory and set up a \filef{Start Menu} shortcut. In order to be
able to compile system definition files a recent version of MinGW (at the time
of writing 5.0.3) should be installed from \url{http://www.mingw.org/} first.
The MinGW installer will ask you to select options. Tick the boxes of the C, C++
compiler and the GNU make utility, the other components are not required.

Installing from source requires more effort. Four other pieces of software has
to be downloaded and installed:
\begin{itemize}
\item[-] MinGW v.\ 5.0.3 or newer as described above,
\item[-] CMake v.\ 2.4.3 or newer from \url{http://www.cmake.org},
\item[-] Qt v.\ 4.2.0 or newer from
\url{http://www.trolltech.com/developer/downloads/qt/windows} (optional, but strongly recommended),
\item[-] and the ATLAS library.
\end{itemize}
To compile the software, first uncompress the \pdde{} package file
\filef{pdde-cont-{\pddever}.tar.bz2} into a convenient directory.
Copy the (pre)compiled ATLAS library files (\filef{libatlas.a} and
\filef{libcblas.a}) into the \filef{pdde-cont-{\pddever}/ATLAS/lib} subdirectory.
Then start a command prompt (Start Menu $\rightarrow$ Run, type ``cmd'' into the
box) and enter the directory \filef{pdde-cont-{\pddever}} where the package was
extracted. If all the requirements are installed and the ATLAS files are in
place, issue the
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
 > build-windows
\end{lstlisting} \end{quote} } \noindent
command, which will build and install the software into \filef{Program
Files$\backslash$PDDE}. The program then can be started from the \filef{bin}
subdirectory. Note that no \filef{Start Menu} entries, no shortcuts are made to
the software, so these steps have to be performed manually if required. To
uninstall, simply delete the PDDE directory.

\section{Command line inferface (CLI)}

The software is controlled by the so-called \emph{constants file}. It is a text file
that contains instructions about all the operations done by the software and
also specifies the parameters of the numerical method.
The name of a constants file can be given to the software using the \funp{-c} option.
If a previous run is continued, an input file should be specified using the \funp{-i} option. 
The output - as a default choice - is written into \filef{pdde.mat} unless it is specified
by the \funp{-o} option. The format of the input and output files will
be described later in this manual. The software also generates an auxiliary file,
which contains the parameter values and the solution norms along the computed
solution branch.
This file can be selected by the \funp{-b} option if this data is not intended
to be written into the \filef{pdde.br} file. The syntax of the command line
arguments is illustrated as
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ pdde -c <constants-file> [ -i <input-file> [ -o <output-file> ] [-b
<branch-file>]]
\end{lstlisting} \end{quote} } \noindent
To display version information use the \funp{-v} command line switch.
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ pdde -v
This is pdde-cont version 1.1.1 (r262 2006-10-03 03:08:22 +0100)
\end{lstlisting} \end{quote} } \noindent


\subsection{The constants file}
\label{constfile}

As an example, we included one of the example problems:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
sys-glass.so            SYSNAME
120                     LABEL
40 P1 0                 TYPE, CP, NPARX, PARX ....
50 4 5 1 1              NINT, NDEG, NMUL, STAB, NMAT
12 12 4 4               NINT1, NINT2, NDEG1, NDEG2 (for torus computations only)
200 -100.0 100.0        STEPS, CPMIN, CPMAX
0.01 0.01 0.01 0.01     DS, DSMIN, DSMAX, DSSTART
1e-4 1e-4 1e-7          EPSC, EPSR, EPSS
12 12 12                NITC, NITR, NITS
\end{lstlisting} \end{quote} } \noindent
In the first separated column are the parameter values, 
while the second column refers to their meaning. 
When this file is read the program interprets only the first half of each line,
that is, it moves to the next line after all the necessary parameters are read.
Although the rest of the line is simply ignored, 
it is useful to keep the mnemonics of the parameters there. The meaning of the
parameters are as follows.
\begin{description}
\item[\funp{SYSNAME}] ~\\
The name of the shared object file,
which contains the system definition. It is the compiled version of a C++
code. For details see section \ref{sysdef}.
%
\item[\funp{LABEL}] ~\\
The solution label in the input file. The program continues this
solution. If \funp{LABEL}=0 it uses the starting solution specified 
in the system definition file.
%
\item[\funp{TYPE}] ~\\
Specifies the type of the solution to be continued. It can be one of the following numbers.
The number surronded by parantheses refers to how many additional free
parameters are required.

Algorithms for time-periodic (non-autonomous) systems:
\begin{description}
\item[\funp{40} -] Continuation of periodic solutions. (0)
%
\item[\funp{41} -] Continuation of fold bifurcations in two parameters (1). The
input is a periodic solution at a fold bifurcation point. The software first
generates a starting point, that is, it tries to converge to the fold point
using a secant method. After the fold point is found with a good accuracy (see
\funp{EPSS}), the tangent of the fold curve is computed so that the continuation
can start. All the bifurcations are started in this way.
%
\item[\funp{42} -] Continuation of period-doubling bifurcations. (1)
%
\item[\funp{43} -] Continuation of Neimark-Sacker (secondary Hopf) bifurcations.
(1)
%
\item[\funp{44} -] Switches to the other solution at a branching point and
follows the orbits. Similar to \funp{TYPE=1}, first the software converges to
the critical solution. Then it computes the critical eigenfunction
$\varphi^{cr}$, which will become the tangent of the new branch, so that the
continuation can start. (0)
%
\item[\funp{45} -] The software first switches to the period-2 branch at a
period doubling bifurcation point
(-1 multiplier) and then follows the arising orbits. (0)
\end{description}
In the case of autonomous systems the above continuations can be carried out in
the same way. The important difference is that the software will use a phase
condition and continue an additional free parameter (e.g., the period). When a
fold bifurcation is continued a different test functional is used to account for
the trivial +1 Floquet multiplier of a periodic orbit.
\begin{description}
\item[\funp{50} -] Continuation of periodic solutions in autonomous systems. The
additional parameter is usually the period length \funp{P0}. (1)
%
\item[\funp{51} -] Continuation of fold bifurcations in two parameters. (2)
%
\item[\funp{52} -] Continuation of period-doubling bifurcations. (2)
%
\item[\funp{53} -] Continuation of Neimark-Sacker (secondary Hopf) bifurcations.
(2)
%
\item[\funp{54} -] Switches to the other solution at a branching point and
follows the orbits. (1)
%
\item[\funp{55} -] The software first switches to the period-2 branch at a
period doubling bifurcation point
(-1 multiplier) and then follows the arising orbits. (1)
%
\item[\funp{56} -] Switches to the periodic solution branch arising at a Hopf
bifurcation point. The input is a constant solution, which represents a fixed
point. The failure or success of the switch depends on the choice of the period
length for the fixed point and the starting solution amplitude \funp{DSSTART}.
As a rule of thumb, the period of the constant solution should be chosen as
small as possible to reliably detect the period of the arising periodic orbit.
If the period is chosen to be large, the detected period will be some integer
multiple of the actual period. (1)
\end{description}
The software can also continue invariant tori arising at Neimark-Sacker
bifurcation points. To continue these quasi-periodic orbits use the following
parameters when restarting from Neimark-Sacker points. This is an experimental
feature. Since the output format was designed for periodic orbits the
quasiperiodic solutions are not written there.
\begin{description}
\item[\funp{20} -] In the case of time-periodic systems
%
\item[\funp{30} -] In the case of autonomous systems.
\end{description}
If none of the above applies to a problem, it is possible to specify the set of
equations and variables used in continuation, by setting the \funp{TYPE} to
\funp{-1}. For details, see the end of this section.
%
\item[\funp{CP}] ~\\
It defines the main continuation parameter. The parameters always start with the
letter `\funp{P}', if they are user defined or with `\funp{I}' if they are
internal parameters, such as the argument of the characteristic multiplier or
the rotation number of a quasiperiodic orbit.
% (Recognition of internal parameters is not yet implemented, however the can be
specified using ordinary parameters. E.g., if \funp{NPAR} is the number of
ordinary parameters then an internal parameter is equivalent to P(\funp{NPAR} +
internal parameter number)). 
These  internal parameters are
\begin{description}
\item[\funp{I0} -] the argument of the characteristic multiplier in the case of
Neimark-Sacker bifurcation continuation and
\item[\funp{I2} -] the rotation number of a two-torus. Usually this is kept
constant in order to avoid phase-locking.
\end{description}
%
\item[\funp{NPARX}] ~\\
Specifies the number of required additional parameters. This must coincide with
the expected value (see \funp{TYPE}).
%
\item[\funp{PARX}] ~\\
A sequence of numbers specifying the additional parameters. In
the case of autonomous problems either \funp{CP} or this should include
\funp{P0}, which refers to the period length.
%
\item[\funp{NINT}] ~\\
Number of collocation intervals; heavily depends on the problem.
%
\item[\funp{NDEG}] ~\\
Degree of polynomials used in collocation. Usually 4 or 5.
%
\item[\funp{NMUL}] ~\\
The number of Floquet multipliers to be computed.
%
\item[\funp{STAB}] ~\\
If zero, stability is not computed along the branch. In any case, \funp{NMUL}
must have a reasonable value, because the eigenvalues are used when computing
the argument of the critical multiplier when starting a Neimark-Sacker
bifurcation continuation.
%
\item[\funp{NMAT}] ~\\
This is the ratio of the maximum delay and the period length. More precisely, it
is the smallest integer such that $\funp{NMAT} \ge \tau_{MAX}/T_{MIN}$.
%
\item[\funp{STEPS}] ~\\
Maximum number of steps on the solution branch.
%
\item[\funp{CPMIN}, \funp{CPMAX}] ~\\
Currently not referenced, just write two numbers.
%
\item[\funp{DS}] ~\\
Starting value of the stepsize in the pseudo-arclength continuation.
It should be reasonably small depending on the problem. \funp{DS} is adapted in
every continuation step between its minimum and maximum value. If the Newton
method exceeds \funp{NITC} iterations and \funp{DS} reached its minimum value,
the continuation is stopped.
%
\item[\funp{DSMIN}, \funp{DSMAX}] ~\\
The minimum and maximum value of \funp{DS}.
%
\item[\funp{DSSTART}] ~\\
Used when branch switching is specified from fixed points to periodic solutions
or from periodic solutions to quasi-periodic tori. The initial solution is
approximated linearly, by adding the unit norm tangent of the new branch
multiplied by \funp{DSSTART} to the fixed point or periodic solution.
%
\item[\funp{EPSC}] ~\\
Tolerance of convergence to a periodic solution during continuation. For
periodic orbit continuation it is about $10^{-5} - 10^{-6}$, for continuation of
bifurcations it can be a bit larger about $10^{-4} - 10^{-5}$ to achieve
reasonable stepsizes (\funp{DS}).
%
\item[\funp{EPSR}] ~\\
Tolerance in the refinement of periodic solutions. (Solution refinement is used
only before continuation starts.) It should be less than or equal to
\funp{EPSC}.
%
\item[\funp{EPSS}] ~\\
Tolerance when converging to a bifurcation point. (Used at branch switching.)
(\emph{Currently \funp{EPSR} is used instead of this.})
%
\item[\funp{NITC}] ~\\
Maximum number of Newton iteration steps in continuation.
%
\item[\funp{NITR}] ~\\
Maximum number of Newton iteration steps, when converging to an initial
solution.
%
\item[\funp{NITS}] ~\\
Maximum number of iteration steps, when finding a bifurcation point.
(\emph{Currently \funp{NITR} is used instead of this.})
%
\end{description}

\subsubsection{User defined equations}
If the \funp{TYPE} constant equals \funp{-1}, the third line of the constants
file is different. For example
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
sys-glass.so						SYSNAME
0										LABEL
-1 P2 0 2 E1 E24 2 S1 P0		TYPE, CP, SWITCH, NEQN, EQN[], NVAR, VAR[]
...
\end{lstlisting} \end{quote} } \noindent
specifies two equations and two variables. The first equation and variable is
always \funp{E1} and \funp{S1}, when a periodic orbit or a periodic solution
bifurcation is continued. In the example, the second equation \funp{E24} is the
phase condition of autonomous systems while the second variable is the period
\funp{P0}. If bifurcations are continued the equations contain at least one of
the test functionals. If more than one, but different test functionals are used,
some codimension-two bifurcations can be continued. The other variables can be
either parameters or one of the internal variables. When a quasi-periodic torus
is computed there is no need to use this extended system definition since the
software is only capable of continuing tori of forced or autonomous systems.

The meaning of the system definition line is described below.
\begin{description}
\item[\funp{CP}] ~\\
	The continuation parameter, same as above.
%
\item[\funp{SWITCH}] ~\\
	The software switches to another branch of solutions if it is non-zero.
\begin{description}
\item[\funp{0} -] No switch.
\item[\funp{1} -] Switches to the other branch at a branching point. %(I hope it
knows which one is which...)
\item[\funp{2} -] Switches to the period-two branch at a period doubling
bifurcation.
\item[\funp{3} -] Switches to the periodic solution branch at a Hopf
bifurcation.
\item[\funp{4} -] Switches to a quasi-periodic torus at a Neimark-Sacker
bifurcation.
\end{description}
\item[\funp{NEQN}] ~\\
	Number of equations.
\item[\funp{EQN}] ~\\
	A sequence of numbers, specifying the equations.
\begin{description}
\item[\funp{E0} -] No equation is used.
\item[\funp{E1} -] Periodic solution. This is always the first equation and can
occur only there.
\item[\funp{E24} -] Phase condition for autonomous systems.
\item[\funp{E25} -] Phase condition for systems with additional symmetry. (For
details, see \cite{haegeman}.)
\item[\funp{E32} -] Quasiperiodic solution on a torus.
\item[\funp{E40} -] The first phase condition for the torus. This is applied
only in the case of autonomous equations.
\item[\funp{E41} -] The second phase condition for the torus. It is always
necessary.
\item[\funp{E64} -] Test functional of fold bifurcation in forced systems.
\item[\funp{E65} -] Test functional of period doubling bifurcation.
\item[\funp{E66} -] Test functional of fold bifurcation in autonomous systems.
%\item[\funp{E67} -] Test functional for fold bifurcations in autonomous systems
%with symmetry. Note: It is working only if the period is not continued.
\item[\funp{E68} -] Real part of the complex test functional for Neimark-Sacker
bifurcation.
\item[\funp{E69} -] Imaginary part of the complex test functional for
Neimark-Sacker bifurcation. This imaginary part should directly follow the real
part in the equation list, otherwise the program will not start the
continuation.
\end{description}
\item[\funp{NVAR}] ~\\
	Number of free variables. This must equal to the number of equations and the
first variable is always the periodic solution.
\item[\funp{VAR}] ~\\
	A sequence of numbers, specifying the free variables. A variable can be one
of the three types. The starting letters are \funp{S}, \funp{P} or \funp{I},
referring to a system variable, parameter or internal variable, respectively.
(For parameters and internal variables see the description of \funp{CP}.) The
system variables are defined as follows.
\begin{description}
\item[\funp{S0} -] No variable is used.
\item[\funp{S1} -] Periodic solution.
\item[\funp{S32} -] Quasi-periodic solution.
\end{description}
In the case of an equation with additional symmetry, when \funp{E25} is
specified, also the symmetric components of the solution has to be declared.
The declaration is the last line of the constants file and contains which parts
of the solution are complex. The first number is the number of complex
solutions,
while the further numbers are the real and imaginary components in the solution
vector. For example
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
...
12 12 12            NITC, NITR, NITS
2 0 1 3 4           NSYM, R0, I0, R1, I1
\end{lstlisting} \end{quote} } \noindent
specifies two symmetric components, where the first complex variable has its
real and imaginary parts in the zeroth and first component of the solution
vector.
Similarly the second rotational symmetric complex solution component has its
real and imaginary part in the third and fourth component of the solution
vector.
\end{description}

\subsection{Input/output file format}

The software uses MAT files to store the results of continuation.
The inner structure of these files are documented in \cite{matfile}. 
These files can be read also by the GNU octave \cite{octave}.
A \pdde{} MAT file contains several matrices, describing a branch of solutions.
The structure of these matrices are defined in Table \ref{matstruct}.
\begin{table}[bth!]
\begin{tabular}{|c|c|c|l|}
\hline
Matrix name & Rows & Columns & Content\\
\hline 
\fun{pdde_npoints} & 1 & 1 & \begin{minipage}[c]{0.4\linewidth} Number of points
computed in the branch of solutions. \end{minipage}\\
\hline
\fun{pdde_par} & \funp{NPAR}+3 & \funp{STEPS} & Values of parameters. \\
\hline
\fun{pdde_mul} & \funp{NMUL} & \funp{STEPS} & The Floquet multipliers. \\
\hline
\fun{pdde_ntrivmul} & 1 & 1 & Number of trivial multipliers. \\
\hline
\fun{pdde_ndim} & 1 & \funp{STEPS} & \begin{minipage}[c]{0.4\linewidth}
\funp{NDIM}: dimesion of the right-hand-side function $f$ \end{minipage}\\
\hline
\fun{pdde_elem} & \funp{NDEG}+1 & \funp{STEPS} & Mesh points in a collocation
interval. \\
\hline
\fun{pdde_mesh} & \funp{NINT}+1 & \funp{STEPS} & Mesh points of the solution
profile. \\
\hline
\fun{pdde_prof} & \funp{NDIM}$\times$(\funp{NINT}$\times$\funp{NDEG}+1) &
\funp{STEPS} & The solution profile. \\
\hline
\end{tabular}
\caption{The contents of the MAT files.}
\label{matstruct}
\end{table}
If the computation stops for some reason, \fun{pdde_npoints} will be less than
\funp{STEPS}, but the size of the MAT file will not be smaller, so only the first
\fun{pdde_npoints} columns will contain valid data.

To convert the input and output MAT files to the format of DDE-BIFTOOL use the
\funp{pmat2branch.m} and \filef{branch2pmat.m} MATLAB scripts found in the \filef{matlab}
subdirectory of the package. The function \funp{pmat2branch.m} takes only one 
input argument, which is the name of a Level 4 MAT file, and returns a periodic 
solution branch structure of DDE-BIFTOOL:
{ \small \begin{quote} \begin{lstlisting}[frame=single]
>> psbr = pmat2branch( 'input-file' );
\end{lstlisting} \end{quote} } \noindent
To export results out of DDE-BIFTOOL and produce a \pdde{} MAT file, issue the command
{ \small \begin{quote} \begin{lstlisting}[frame=single]
>> branch2pmat( 'output-file', psbr, NMUL );
\end{lstlisting} \end{quote} } \noindent
where \funp{NMUL} is the same number as in the constants file where the exported data 
will be used as a starting solution.

\subsection{Structure of the ASCII input/output file}
[Note: This section is no longer valid, because ASCII output files are not used anymore.]

The output file contains all the computed information of a periodic solution 
branch. Also, this file can be used to restart the continuation from a point 
on a branch. The above defined restart \funp{LABEL} refers 
to the number of a line in this file. The structure of a line is described 
in Table \ref{iostruct}.
\begin{table}
\begin{tabular}{|c|c|l|}
\hline
Starting & Length & Content\\
Column & & \\
\hline
1             & 1       & \begin{minipage}[c]{0.5\linewidth} \funp{NPAR}, the
number of parameters plus the number of internal parameters, which is 3.
\end{minipage}\\
\hline
2             & \funp{NPAR} & Values of parameters\\
\hline
\funp{NPAR}+2  & 1       & \funp{NMUL}: number of Floquet multipliers\\
\hline
\funp{NPAR}+3  & $2\times$\funp{NMUL} & \begin{minipage}[c]{0.5\linewidth} The
Floquet multipliers. ( Re($\lambda_1$), Im($\lambda_1$), ...,
Re($\lambda_{NMUL}$), Im($\lambda_{NMUL}$) ) \end{minipage} \\
\hline
\funp{NPAR}+$2\times$\funp{NMUL}+3
              & 1       & \begin{minipage}[c]{0.5\linewidth} \funp{NDIM}:
dimesion of the right-hand-side function $f$ \end{minipage}\\
\hline
\funp{NPAR}+$2\times$\funp{NMUL}+4 & 1       & \funp{NINT}: number of
collocation intervals\\
\hline
\funp{NPAR}+$2\times$\funp{NMUL}+5 & 1       & \funp{NDEG}: degree of
collocational polynomials\\
\hline
\funp{NPAR}+$2\times$\funp{NMUL}+6 & \funp{NINT}$\times$\funp{NDEG}+1 & Mesh of
the $[0,1]$ interval. \\
\hline
\begin{minipage}{0.2\linewidth} \begin{center}
\funp{NPAR}+$2\times$\funp{NMUL}+\\
\funp{NINT}$\times$\funp{NDEG}+7
\end{center} \end{minipage} & 
\funp{NDIM}$\times$(\funp{NINT}$\times$\funp{NDEG}+1) & 
\begin{minipage}[c]{0.5\linewidth} The solution profile, a sequence of
\funp{NDIM}-tuples \end{minipage} \\
\hline
\end{tabular}
\caption{The structure of a line in the ASCII input/output files.}
\label{iostruct}
\end{table}

It is possible to convert the solution profile from DDE-BIFTOOL to this format
and back. For this use the matlab scripts \filef{dde2pdde.m} or
\filef{pdde2dde.m} in the \filef{matlab} subdirectory in the following way.
Assume that there is branch of periodic solutions (\funp{psbr}). This branch can
be exported using the command
{ \small \begin{quote} \begin{lstlisting}[frame=single]
>> dde2pdde( 'output-file', psbr.point, NMUL );
\end{lstlisting} \end{quote} } \noindent
Here, \funp{NMUL} is the same number what is specified in the constants file
under the same name.
Similarly, the results can be converted back into DDE-BIFTOOL using the command
{ \small \begin{quote} \begin{lstlisting}[frame=single]
>> psbr.point = pdde2dde( 'output-file' );
\end{lstlisting} \end{quote} } \noindent

\subsection{Defining an equation}

The software uses custom C++ data types to represent matrices and vectors,
which are called \fun{Matrix} and \fun{Vector}, respectively. For indexing
these arrays, parentheses are used, that is, the first element of a
\fun{Vector} \fun{v} is always \fun{v(0)}, the size of the \fun{Vector} is
\fun{v.Size()} and its last
element is \fun{v(v.Size()-1)}. A \fun{Matrix} is indexed similarly, e.g., in
the case of \fun{Matrix m}, \fun{m(i,j)} means the \fun{(j-1)}-th element in the
\fun{(i-1)}-th row of the matrix. The number of columns and rows of \fun{m} can
be can be queried by calling \fun{m.Col()} and \fun{m.Row()}, respectively.

\subsubsection{System definition}\label{sysdef}

The system definition file is a C++ source file, which is compiled by the user
and then loaded by the main program \filef{pdde} as a shared object. The
compilation is done typically by issuing the command%
\footnote{Note that \filef{pcompile} is not available on Microsoft Windows.}
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ pcompile sys-<problem>.cpp
\end{lstlisting} \end{quote} } \noindent
which produces the file \filef{sys-$<$problem$>$.so}.
The system definition should include the header file \filef{pddesys.h}
(\fun{#include pddesys.h}), which defines the syntax of the functions. Also, all
the functions must be declared as \fun{extern "C"}, to make their names
independent of the C++ name mangling. The definition of a system of equations in
\pdde{} is similar to DDE-BIFTOOL \cite{DDEBIF}. The common input variables that
are passed to the user defined functions are
\begin{itemize}
  \item[-] \fun{t} (\fun{double}) is the time instance within a period. It is
  scaled into $[ 0, 1 ]$ by the period length $T$, i.e., \fun{t}$ = t/T$.
  \item[-] \fun{par} (\fun{Vector}) is a vector and contains the parameters of
  the system. \fun{par(0)} is always the period ($T$) of the actual orbit,
  while others can be chosen.
  \item[-] \fun{xx} (\fun{Matrix}) contains the solution values at $t -
  \tau_i$, that is, \fun{xx( j, i )}$= [ x ( t - \tau_i ) ]_{(j+1)}$, where
$\tau_0$ is generally zero.
\end{itemize}
The required functions are
\begin{itemize}
  \item[-] \fun{ int sys_ndim(); } \\ 
  This function returns the dimension of the
  system. e.g.: \fun{ int sys_ndim() \{ return 2; \} }
  
  \item[-] \fun{ int sys_npar(); } \\ 
  This function returns the number of parameters. It
  includes the period $T$, which is the 0th parameter.
  
  \item[-] \fun{ int sys_ntau(); } \\ 
  This function returns the number of delays including the non-delayed term $x (
t )$, too.
  
  \item[-] \fun{ int sys_nderi(); } \\ 
  This function returns the order of supplied derivatives. In case of $0$ the
\fun{sys_deri(...)} can be empty, although should be defined. For $1$ only the
first order derivatives with respect to the state variables and the parameters
need to be supplied. If the returned value is $2$ all the required derivatives
are supplied by the user. The internal computation technique of the derivatives
is the same as in DDE-BIFTOOL, which is the finite difference method. The
derivatives are computed recursively, so the second order derivatives are
calculated using the first order derivatives.
  
  \item[-] \fun{ void sys_tau( Vector\& out, double t, const Vector\& par ); }
\\
  \fun{out} is the output variable and contains the vector of delays
  including a zero for the non-delayed term. For example for $\dot{x} ( t ) =
  f ( t, x ( t ), x ( t - T ) )$ \fun{out} is a vector with 2 elements:
  \fun{out(0)}$=0.0$, \fun{out(1) = par(0)}.
  
  \item[-] \fun{void sys_dtau( Vector\& out, double t, const Vector\& par, int p
);} \\
  \fun{out} contains the derivatives of delays with respect to the parameter
  \fun{p}. If \fun{p==0} in the above example, the result is
  \fun{out(0)=0.0} and \fun{out(1)=1.0}.
  
  \item[-] \fun{void sys_rhs( Vector\& out, double t, const Matrix\& xx, const
Vector\& par );} \\ 
  The output \fun{out} is simply $f ( t, x ( t ), \ldots, x ( t - \tau_i ),
\ldots )$.
  
  \item[-] \fun{void sys_deri( Matrix\& out, double t, const Matrix\& xx, const
Vector\& par, int nx, int* vx, int np, int* vp, const Matrix\& v );} \\
  This function supplies the derivatives of $f$ with respect to variables and
parameters. As mentioned before, this function can be empty or can supply some
or all the necessary derivatives.
  \fun{nx} is the queried order (0, 1 or 2) of derivatives with respect to $x( t
-
  \tau_{\mathrm{vx[0]}} )$, and \fun{vx[nx]} specifies which argument(s) of $f$
is used in
  the differentiation. For example if \fun{nx==1}, \fun{vx[0]} tells which
delayed value of the state variable is used in the differentiation. 
  If \fun{nx==2}, the second derivative is calculated with respect to $x( t -
  \tau_{\mathrm{vx[0]}} )$ and $x( t - \tau_{\mathrm{vx[1]}} )$ resulting in a 3
index tensor, which is finally multiplied by the \fun{vx[1]} the column of
\fun{v} to get a matrix.
  Derivatives with respect to parameters are requested if \fun{np==1}. If
\fun{nx==0} the output is a vector, because it is the derivative of the
right-hand side only with respect to the scalar \fun{par(vp[0])}. However, if
\fun{nx==1}, the first order derivative w.r.t. the state variables is
differentiated further with respect to the \fun{par(vp[0])} resulting in a
matrix.
  \begin{table}
  \begin{center}
  \begin{tabular}{ c c c|c }
  \fun{nx} & \fun{np} & \fun{v} & \fun{out} \\
  \hline
  1 & 0 & --- & $\ds \frac{\partial f}{\partial x(t-\tau_{\mathrm{vx[0]}})} =
A_{\mathrm{vx[0]}} \in \mathbb{R}^{n \times n}$ \\
  0 & 1 & --- & $\ds \frac{\partial f}{\partial \eta_{\mathrm{vp[0]}}} \in
\mathbb{R}^{n \times 1}$\\
  1 & 1 & --- & $\ds \frac{\partial^2 f}{\partial x(t-\tau_{\mathrm{vx[0]}})
\partial \eta_{\mathrm{vp[0]}}} \in \mathbb{R}^{n \times 1}$ \\
  2 & 0 & $\ds \in \mathbb{R}^{n \times \funp{NTAU}}$ & $\ds
\frac{\partial}{\partial x(t-\tau_{\mathrm{vx[1]}})} \left( A_{\mathrm{vx[0]}}
v(\,.,\mathrm{vx[0]}) \right) $
  \end{tabular}
  \end{center}
  \caption{Possible outputs of \fun{void sys_deri(...)}. }
  \end{table}
  
  \item \fun{void sys_stpar( Vector\& par );} \\
  This function returns the parameter values at the starting point, which is a
known periodic solution of the system.
  
  \item \fun{void sys_stsol( Vector\& out, double t );} \\
  This function returns the value of the known periodic solution at time
\fun{t}.
\end{itemize}

\subsection{Running the software}

After invoking the software \filef{pdde}, it either loads a solution profile
from the input file (see Sect.\ \ref{constfile}) or uses the 
\fun{sys_stpar} and \fun{sys_stsol} functions (see Sect.\ \ref{sysdef})
depending on the value of \funp{LABEL} to obtain an approximate solution at a
given value of parameters. There are three steps of initializations before the
continuation starts:
\begin{enumerate}
\item The software starts a Newton iteration to converge to a more precise
solution.
\item If there is a bifurcation involved, e.g., in case of a bifurcation
continuation or branch switching, the software tries to find the bifurcation
point using a Newton method. Clearly, if there is no bifurcation point in a
sufficiently small neighborhood of the specified solution, this step will fail.
In very rare cases and for `difficult' problems, if the first and second
derivatives of the right hand side are computed numerically (\fun{sys_nderi}
returns zero or one), the search for a bifurcation can fail even when the
starting solution is the bifurcation point with high accuracy.
\item It finds the tangent of the solution branch at its first point. In
general, it computes the tangent as a kernel vector of the linearized defining
system. In the case of branch switching, the critical eigenfunctions are used to
construct the tangent vector.
\end{enumerate}
If any of the above tasks fail, or the convergence is not reached within the
specified number of steps and accuracy, the program stops.
After all this initializations, the program starts the continuation and writes
the data into the output and branch files.

\subsubsection{The console output}

First, the software writes the content of the constants file (see Sect.\
\ref{constfile}) to the standard output (console). Then it starts the Newton
iteration:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
IT      ERR             SOLnorm         DIFFnorm
 0      5.772096e-02    9.234583e-01    1.110239e-01
 1      6.083138e-02    9.279196e-01    1.172780e-01
 2      1.271950e-02    9.283746e-01    2.452796e-02
 3      7.432386e-04    9.283646e-01    1.433235e-03
 4      1.490474e-06    9.283646e-01    2.874176e-06
\end{lstlisting} \end{quote} } \noindent
Here, each iteration step (\funp{IT}) is displayed: \funp{SOLnorm} is the $L^2$
norm of the solution and \funp{DIFFnorm} is the $L^2$ norm of the difference
between the new and the previous approximate solution. \funp{ERR} refers to the
stopping criterion, that is
\[
	\funp{ERR} = \frac{\funp{DIFFnorm}}{1+\funp{SOLnorm}} < \funp{EPSR}.
\]
If the prescribed accuracy is not reached, but \funp{IT} reaches \funp{NITR},
the program stops with error.

In the next step, if appropriate, the program tries to find the bifurcation
point. This is done by the same Newton method, so it will quickly converge if
the bifurcation point is sufficiently close:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
--- Finding the bifurcation point (TF) ---

IT      ERR             SOLnorm         DIFFnorm
 0      3.521412e-04    9.141656e-01    6.740565e-04
 1      8.795736e-06    9.141643e-01    1.683648e-05
\end{lstlisting} \end{quote} } \noindent

The main continuation proceeds similarly:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
LABEL      NORM         P2              P0              USTAB   IT
  1     9.142448e-01    1.556134e+00    1.101504e+01      0     2
  2     9.143658e-01    1.557164e+00    1.101898e+01      0     1
  3     9.144963e-01    1.558277e+00    1.102330e+01      0     1
\end{lstlisting} \end{quote} } \noindent
The first column, \funp{LABEL} is the solution label in the output file, while
the second column is the $L^2$ norm of the solution. From the third column on,
the free parameters are displayed. The column denoted by \funp{USTAB} refers to
the number of unstable characteristic roots, if stability computation is turned
on (see \funp{STAB} below), otherwise it is meaningless. The last column is the
number of the Newton iterations, within each continuation step.

\subsection{Example: Mackey-Glass equation}

Here we discuss the continuation steps in the case of a simple one dimensional
delay-differential equation. Although the equation is simple, it shows quite
complicated dynamics including chaos. Our equation reads
\begin{equation}
  \dot{x} ( t ) = ax ( t ) + b \frac{x ( t - \tau )}{1 + x^{10} ( t - \tau )}.
\label{ct:glass}
\end{equation}
This equation describes proliferation of white blood cells and was first
introduced by Mackey and Glass in {\cite{mackey}}. Equation (\ref{ct:glass})
has three equilibrium solutions $x_1 = 0$ and $x_{2, 3} = \sqrt[10]{- ( a + b
) / a}$, which connect to each other at $a = - b$ by a supercritical pitchfork
bifurcation. The nonzero solutions can lose their stability through Hopf
bifurcation described by the parametric curves
\begin{align*}
  a & =-\arccos(-d^{-1}){\frac{1}{{\tau} {\sqrt[10]{d^2-1}}}}\\
  b & ={\frac{10a}{d-9}},
\end{align*}
where $|d| \ge 1$. Hopf bifurcations for $d > 1$ are supercritical, which give
rise to stable periodic orbits. These periodic orbits bifurcate further by
several period doublings leading to chaotic motion. It was demonstrated by
Hale and Sternberg {\cite{sternberg}} that chaos arises due to the transverse
intersection of the two dimensional unstable and infinite dimensional stable
manifold of this periodic orbit.

The system definition file can be found in the directory
\filef{demo/glass/sys-glass.cpp}. The first few functions are trivial:
{ \small \begin{quote} \begin{lstlisting}[frame=single]
#include "pddesys.h"
#include <cmath>

extern "C" {
int sys_ndim(){ return 1; }
int sys_npar(){ return 4; }
int sys_ntau(){ return 2; }
int sys_nderi(){ return 2; }
} // extern "C"
\end{lstlisting} \end{quote} } \noindent
Here we have four parameters:
\funp{P0}$\to T$, the period length;
\funp{P1}$\to a$;
\funp{P2}$\to b$; and
\funp{P3}$\to \tau$, the delay.
The total number of delays is two, because we have a non-delayed and a delayed
term.
The functions that define the delays are
{ \small \begin{quote} \begin{lstlisting}[frame=single]
extern "C"
void sys_tau( Vector& out, double t, const Vector& par ) 
{
	out(0) = 0.0;
	out(1) = par(3);
}

extern "C"
void sys_dtau( Vector& out, double t, const Vector& par, int p ) 
{
	switch( p )
	{
		case 0:
			out(0) = 0.0; out(1) = 0.0; break;
		case 1:
			out(0) = 0.0; out(1) = 0.0; break;
		case 2:
			out(0) = 0.0; out(1) = 0.0; break;
		case 3:
			out(0) = 0.0; out(1) = 1.0; break;
	}
}
\end{lstlisting} \end{quote} } \noindent
The values of the delays are returned by \fun{sys_tau(...)} in the \fun{out}
vector, while their derivatives with respect to the \fun{p}-th parameter are
returned by \fun{sys_dtau(...)}.

The right-hand side of the equation is defined as (see (\ref{ct:glass}))
{ \small \begin{quote} \begin{lstlisting}[frame=single]
extern "C"
void sys_rhs( Vector& out, double t, const Matrix& x, const Vector& par )
{
	out(0) = par(1)*x(0,0) + par(2)*x(0,1)/(1.0+pow(x(0,1), 10.0));
}
\end{lstlisting} \end{quote} } \noindent
Here, the non-delayed term is \fun{x(0,0)} while the delayed term
is \fun{x(0,1)}.

The most difficult part of the definition is always the derivatives of the
right-hand side. (Note that the construction of this function can be avoided by
returning zero in \fun{ int sys_nderi(); }.)
{ \small \begin{quote} \begin{lstlisting}[frame=single]
extern "C"
void sys_deri( Matrix &out, double t, const Matrix& x, const Vector& par, 
					int nx, const int* vx, int np, const int* vp, const Matrix& vv )
{
	// derivatives w.r.t. the dependent variables: x(t), x(t-tau1), etc.
	if( (nx == 1) && (np == 0) ) {
		switch( vx[0] ) {
			case 0:
				out(0,0) = par(1); break;
			case 1:
				out(0,0) = par(2)*(1.0 - 9.0*pow(x(0,1), 10.0) )/
					( (1+pow(x(0,1), 10.0))*(1+pow(x(0,1), 10.0)) ); break;
		}
	}
	// derivatives w.r.t. the parameters, purely, so this results a vector
	if( (nx == 0) && (np == 1) )
	{
		switch( vp[0] )
		{
			case 1:
				out(0) = x(0,0); break;
			case 2:
				out(0) = x(0,1)/(1+pow(x(0,1), 10)); break;
			case 3:
				out(0) = 0.0; break;
		}
	}
	// second derivatives w.r.t. x
	if( (nx == 2) && (np == 0) ) {
		switch( vx[0] ) {
			case 0:
				switch( vx[1] ) {
					case 0:
						out(0,0) = 0.0; break;
					case 1:
						out(0,0) = 0.0; break;
				} break;
			case 1:
				switch( vx[1] ) {
					case 0:
						out(0,0) = 0.0; break;
					case 1:
						out(0,0) = 10.0*par(2)*pow(x(0,1), 9.0)*
							(9.0*pow(x(0,1), 10.0) - 11.0)/
							pow((1.0+pow(x(0,1), 10.0)), 3.0) * vv(0,1); break;
				} break;
		}
	}
	// mixed derivative w.r.t. x and the parameters
	if( (nx == 1) && (np == 1) ) {
		switch( vp[0] ) {
			case 1:
				switch( vx[0] ) {
					case 0:
						out(0,0) = 1.0; break;
					case 1:
						out(0,0) = 0.0; break;
				} break;
			case 2:
				switch( vx[0] ) {
					case 0:
						out(0,0) = 0.0; break;
					case 1:
						out(0,0) = (1.0 - 9.0*pow(x(0,1), 10.0) )/
							((1.0 + pow(x(0,1), 10.0))*(1.0+pow(x(0,1), 10.0)) );
						break;
				} break;
			case 3:
				switch( vx[0] ) {
					case 0:
						out(0,0) = 0.0; break;
					case 1:
						out(0,0) = 0.0; break;
				} break;
		}
	}
}
\end{lstlisting} \end{quote} } \noindent

The first thing in analyzing the problem is to find periodic solution
branches. In our case we have a supercritical Hopf bifurcation, hence we look
for solutions around the unstable fixed points and continue them along
parameter $b$ (\funp{P2}). The corresponding constants file
(\filef{cfile-start}) is
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
sys-glass.so            SYSNAME
0                       LABEL
50 P2 1 P0              TYPE, CP, NPARX, PARX ....
200 4 5 1 1             NINT, NDEG, NMUL, STAB, NMAT
12 12 4 4               NINT1, NINT2, NDEG1, NDEG2
120 -100.0 100.0        STEPS, CPMIN, CPMAX
-0.002 0.002 0.002 0.1  DS, DSMIN, DSMAX, DSSTART
1e-5 1e-5 1e-6          EPSC, EPSR, EPSS
12 12 12                NITC, NITR, NITS
\end{lstlisting} \end{quote} } \noindent
Invoke the program:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ pdde -c cfile-start -o in-start
\end{lstlisting} \end{quote} } \noindent
Checking the the console output, we find that there is a change in
stability between labels 111 and 112, marked by the ``\funp{PD}'' sign referring
to period doubling.
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
IT      ERR             SOLnorm         DIFFnorm
 0      2.194757e-01    9.672925e-01    4.317730e-01
 |          |               |               |
 4      3.833364e-05    9.283690e-01    7.392141e-05
 5      5.213321e-09    9.283690e-01    1.005321e-08

--- Starting the continuation ---

IT      ERR             SOLnorm         DIFFnorm
 0      4.404573e-05    9.283690e-01    8.493641e-05
 1      1.577228e-08    9.283690e-01    3.041478e-08

LABEL      NORM            PAR(2)          PAR(0)
  0     9.283690e-01    1.740060e+00    5.391800e+00

LABEL      NORM            PAR(2)          PAR(0)       USTAB
  1     9.282553e-01    1.738491e+00    5.392977e+00      1
  2     9.281415e-01    1.736923e+00    5.394156e+00      1
  |         |               |               |             |
  110   9.144253e-01    1.558730e+00    5.505050e+00      1
  111   9.142811e-01    1.556917e+00    5.505700e+00      1
  112   9.141366e-01    1.555100e+00    5.506339e+00      0  PD
  113   9.139919e-01    1.553281e+00    5.506966e+00      0
\end{lstlisting} \end{quote} } \noindent
This period doubling bifurcation can be continued in two parameters 
by changing the solution type to \funp{12} and including an additional
parameter.
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
sys-glass.so            SYSNAME
112                     LABEL
52 P2 2 P0 P1           TYPE, CP, NPARX, PARX ....
...
\end{lstlisting} \end{quote} } \noindent
The continuation starts with the following command
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
$ pdde -c cfile-pdbif -i in-start
\end{lstlisting} \end{quote} } \noindent
The period doubling curve can be seen in Fig.\ \ref{pdbif}.
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.6]{fig/pdbif2.eps}
\end{center}
\caption{Period doubling bifurcation curve of the period-1 solution.}
\label{pdbif}
\end{figure}
Also, the arising period-2 orbits can be computed by switching to this new
branch of solutions:
{ \small \begin{quote} \begin{lstlisting}[basicstyle=\tt,frame=single]
sys-glass.so            SYSNAME
112                     LABEL
55 P2 1 P0              TYPE, CP, NPARX, PARX ....
...
\end{lstlisting} \end{quote} } \noindent
%
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.6]{fig/pdsw.eps}
\end{center}
\caption{The period-2 branch. Period doublings are denoted by $\times$, while
$\circ$ refers to fold bifurcation. }
\label{pdsw}
\end{figure}
Figure \ref{pdsw} shows the bifurcation diagram of the period-2 orbit. Using the
previous methods we continue the bifurcations on this period-2 branch, which
gives a more detailed information about the solutions. A three dimensional
bifurcation diagram can be seen in Fig.\ \ref{pdfold}, which shows the
complicated orbit structure.
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.6,angle=270]{fig/fold3d-2.eps}
\end{center}
\caption{Fold bifurcations of the period-2 orbits. Black curves are periodic
solutions continued along $b=$ constant lines. Red curves refer to fold
bifurcations, while the blue line is the period doubling curve, where the
period-2 orbits arise. }
\label{pdfold}
\end{figure}

\section{The graphical user interface (GUI)}

The graphical user interface of the software is a front-end to the computation
library of \pdde{}. It can do the same operations as the CLI, however many things are
hidden from the user, so it might appeal to non-expert users. It includes a plotting
facility which can be used to preview the results.

The main window in Fig.\ \ref{mainwindow} appears
when the program \filef{pdde-gui} is started.
It has a menu and toolbar which 
contains the \filef{Open} \iconOpen{}, \filef{Save} \iconSave{},
\filef{Run} \iconRun{}, \filef{Stop} \iconStop{} and
\filef{Text} \iconText{} buttons. The \filef{Open} \iconOpen{} button pops up a
file chooser so that an XML-formatted constants file can be chosen. This
XML-file contains the same parameters as the plain constants file (see section
\ref{constfile}). Note that, when opening a constants file an error message will pop up if
the system definition is not compiled yet. To resolve the problem compile the C++ source
of the system definition using the \filef{Compile} \iconBuild{} button.

The constants file is an XML-file, which contains the same parameters as the
plain constants file of the CLI, for details see section \ref{constfile}. 
The contents of this XML file can be edited in the four tabs \filef{System},
\filef{Numerics}, \filef{Symmetry} and \filef{Torus} and then can be saved
either using the \filef{Save} \iconSave{} button or the \filef{Save As...}
\iconSaveAs{} menu item in the \filef{File} menu.
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.5]{fig/mainwindow.eps}
\caption{The main window of the software.}
\label{mainwindow}
\end{center}
\end{figure}

The \filef{System} tab contains the parameters of the defining system and the
input/output. The \filef{INPUT} and \filef{OUTPUT} labels refer to the input and
output MAT files. These files can be opened using the \filef{Browse} \iconOpen{}
buttons and their contents can be visualized using the \filef{Plot}
\iconPencil{}
buttons. As before, the \filef{LABEL} spinbox contains the solution label in
the input file that is used as a starting point in the numerical continuation.

The system definition file can be selected in the \filef{SYSNAME} line by
opening a shared object (\filef{.so}) file of compiling it from a C++ source
(\filef{.cpp}) file.

The \filef{POINT TYPE} can be selected from the following choices
\begin{itemize}
\item[-] User - user defined equations (not recommended, use
it with symmetric equations only). The equations (\filef{Eqn}) and the
variables (\filef{Var}) have to be selected in the table;
\item[-] Limit cycle - a periodic solution of a forced system, \filef{NPARX}=0. Note that the solution type also can be used to continue equilibria of autonomous systems by keeping the period constant.
\item[-] Limit point - fold bifurcation of a periodic solution in a forced
system, \filef{NPARX}=1;
\item[-] Period doubling - period doubling (flip) bifurcation of a periodic
solution in a forced system, \filef{NPARX}=1;
\item[-] Neimark-Sacker - Neimark-Sacker (secondary Hopf, Torus) bifurcation of
a periodic solution in a forced system, \filef{NPARX}=1;
\item[-] Branch switch - switch to the other branch at a branching point in a
forced system, \filef{NPARX}=0;
\item[-] Period doubling switch - switch to the period-two branch at a period
doubling point in a forced system, \filef{NPARX}=0;
\item[-] Limit cycle (aut)- a periodic solution of a forced system,
\filef{NPARX}=1;
\item[-] Limit point (aut) - fold bifurcation of a periodic solution in an
autonomous system, \filef{NPARX}=2;
\item[-] Period doubling (aut) - period doubling (flip) bifurcation of a
periodic solution in an autonomous system, \filef{NPARX}=2;
\item[-] Neimark-Sacker (aut) - Neimark-Sacker (secondary Hopf, Torus)
bifurcation of a periodic solution in an autonomous system, \filef{NPARX}=2;
\item[-] Branch switch (aut) - switch to the other branch at a branching point
in an autonomous system, \filef{NPARX}=1;
\item[-] Period doubling switch (aut) - switch to the period-two branch at a
period doubling point in an autonomous system, \filef{NPARX}=1;
\item[-] Torus from NS - branch switching from a Neimark-Sacker bifurcation
point to a quasi-periodic torus in a forced system, \filef{NPARX}=1;
\item[-] Torus from NS - branch switching from a Neimark-Sacker bifurcation
point to a quasi-periodic torus in an autonomous, \filef{NPARX}=2;
\end{itemize}
The solution can be continued along the \filef{CP} continuation parameter. If
the \filef{NPARX} parameter is not zero then additional parameter(s)
\filef{PARX} has (have) to be selected from the numbered system parameters
starting with \filef{P} or the two internal parameters the \filef{Rotation
number} (only for tori) and \filef{Angle NS}, which is the argument of the
critical multiplier and can only be selected with the user defined equations.
If the user defined equations are selected it is possible select branch with
the \filef{SWITCH} option.

The \filef{Numerics} tab contains the parameters of the continuation method and
the option of computing stability. For details see section \ref{constfile}.

In the \filef{Symmetry} tab the complex rotational symmetric components of the
solution can be specified. If the parameter \filef{NSYM} is non-zero only the
user defined equations can be used.

The \filef{Torus} tab specifies the mesh parameters of the staggered grid
Chebyshev collocation method when computing quasi-periodic tori.

\subsection{Computing a branch of solutions}

If all the parameters are set up it is recommended to \filef{Save} \iconSave{}
(or \filef{Save As...} \iconSaveAs{} the settings. To start the computation
press the \filef{Run} \iconRun{} button. Pressing the \filef{Stop} \iconStop{}
button will stop the computation after the approximation of the current point on
the branch is finished.

\subsection{Viewing the results}

The result of the computation can be viewed in textual form. Pressing the
\filef{Text} \iconText{} button in the main window
will pop up the text window (see Fig.\ \ref{textwindow}) that constains almost
the same output as the terminal output of the CLI.
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.5]{fig/textwindow.eps}
\caption{Textual output view.}
\label{textwindow}
\end{center}
\end{figure}

The solutions branch can also be visualized in a graph in the plotting window (Fig.\
\ref{plotwindow}). If a solution branch is plotted the bifurcation points are
denoted by square, triangle and cross signs in the case of fold, period doubling
and Neimark-Sacker bifurcations, respectively. Note that on Microsoft Windows it is not
possible to plot the results in the middle of a computation. On Linux it is not
a restriction.
\begin{figure}[bth!]
\begin{center}
\includegraphics[scale=0.5]{fig/plotwindow.eps}
\caption{Plotting window.}
\label{plotwindow}
\end{center}
\end{figure}

\section{Algorithms used in the software}

The software uses orthogonal collocation to discretize periodic orbits
\cite{engstab,engcol}. It is also possible to use staggered grid Chebyshev
collocation \cite{kopriva} by changing the collocation and representation points
in \filef{src/ncolloc.cpp}. For continuation, the pseudo arclength method is
used (see, e.g., \cite{handbook, tutorial1, tutorial2}). Codimension-one
bifurcations are computed using the test functionals. The arising bordered
sparse linear systems are solved using the BEMW method developed by Govaerts and
Pryce \cite{Gov1993}. The sparse part of the linear system is factorized by
UMFPACK \cite{umfpack}. Quasiperidic orbits are computed using the spectral
method mentioned above \cite{kopriva}.

\subsection*{Acknowledgments}

The author is highly indebted to G\'abor St\'ep\'an (Budapest University of 
Technology and Economics) for his constant support. He is also
obliged to S.~John Hogan for partially supporting a 5 month visit at the
University of Bristol.
This research was supported financially by a Hungarian E\"otv\"os Scholarship
and a Fulbright grant.

\appendix

\section{Licenses}

\subsection{PDDE-CONT}

In addition to the GNU General Public License below the user of the software or
the author of any
publication containing results obtained using \pdde{} or any of its modified
version is required to refer to the present User's Manual.
\begin{quote}
Robert Szalai, \pdde{}: A continuation and bifurcation software for 
delay-differential equations, Tech.\ Rep., Budapest University of Technology
and Economics (2005)
\end{quote}
In the case of modification of the program please notify the original author and
include a clear description about what was modified and who did the 
modification. Please state clearly that any contribution to this software
contains code which can and will be distributed under the GNU General Public
License.

\begin{quote}
PDDE-CONT. A continuation and bifurcation software for delay-differential
equations \\
Copyright (C) 2005 by Robert Szalai \\

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2 as published by
the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
\end{quote}

\subsection{UMFPACK and AMD}

\noindent
UMFPACK Version 4.6, Copyright (c) 2005 by Timothy A. Davis.
All Rights Reserved.
UMFPACK is available under alternate licenses, contact T. Davis for details.\\
\url{http://www.cise.ufl.edu/research/sparse/umfpack}\\
Your use or distribution of UMFPACK or any modified version of
UMFPACK implies that you agree to this License.

\noindent
AMD Version 1.1 (Jan. 10, 2004),
Copyright (c) 2004 by Timothy A.~Davis, Patrick R.~Amestoy, and Iain S.~Duff.
All Rights Reserved.\\
\url{http://www.cise.ufl.edu/research/sparse/amd}\\
Your use or distribution of AMD or any modified version of
AMD implies that you agree to this License.

UMFPACK and AMD License:
\begin{quote}
    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
    USA

    Permission is hereby granted to use or copy this program under the
    terms of the GNU LGPL, provided that the Copyright, this License,
    and the Availability of the original version is retained on all copies.
    User documentation of any code that uses this code or any modified
    version of this code must cite the Copyright, this License, the
    Availability note, and "Used by permission." Permission to modify
    the code and to distribute modified code is granted, provided the
    Copyright, this License, and the Availability note are retained,
    and a notice that the code was modified is included.
\end{quote}

\bibliographystyle{plain}
\bibliography{manual-bibl.bib} \label{sec:bibliography}


\end{document}
