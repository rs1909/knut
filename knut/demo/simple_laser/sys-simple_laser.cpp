//
// Knut KNSystem Definition file for the VFGEN vector field: laser
//
// This file was generated by the program VFGEN (Version:"2.4.0")
// Generated on 28-Apr-2012 at 14:33
//

#include <cmath>
#include "knutsys.h"

static inline double heaviside(double x)
{
  if (x > 0) return 1.0;
  else return 0.0;
}

static inline double ramp(double x)
{
  if (x > 0) return x;
  else return 0.0;
}

extern "C" {

size_t sys_ndim()  { return 3; }  // KNSystem dimension
size_t sys_npar()  { return 8; }  // Number of parameters, plus one (for the period)
size_t sys_ntau()  { return 2; }  // Number of delays, plus one
size_t sys_nderi() { return 2; }  // Order of derivatives computed here
size_t sys_nevent() { return 0; }  // Number of event functions

//
// sys_p_rhs(...) computes the vector field.
//
void sys_p_rhs(KNArray2D<double>& out, const KNArray1D<double>& time, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_, size_t sel)
{
  // Compute the vector field
  for (size_t idx=0; idx < time.size(); ++idx)
  {
    const double t = time(idx);
    out(0,idx) =  Zlags_(1,1,idx)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)+Zlags_(1,0,idx)*par_(5)+Zlags_(0,1,idx)*par_(3)*cos(par_(6)*( par_(7)+par_(5)))+Zlags_(0,0,idx)*Zlags_(2,0,idx)-Zlags_(1,0,idx)*par_(1)*Zlags_(2,0,idx);
    out(1,idx) =  Zlags_(1,0,idx)*Zlags_(2,0,idx)-Zlags_(0,1,idx)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)+Zlags_(0,0,idx)*par_(1)*Zlags_(2,0,idx)-Zlags_(0,0,idx)*par_(5)+Zlags_(1,1,idx)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
    out(2,idx) = -( ( 2.0*Zlags_(2,0,idx)+1.0)*( pow(Zlags_(0,0,idx),2.0)+pow(Zlags_(1,0,idx),2.0))-par_(4)+Zlags_(2,0,idx))/par_(2);
  }
}

//
// This function computes the Jacobian of the vector field
// with respect to the k-th delayed vector.
//

static inline void __jacx(KNArray3D<double>& out, const KNArray1D<double>& time, size_t k, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_)
{
  if (k == 0)
  {
    // Derivatives wrt the state variables
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = Zlags_(2,0,idx);
      out(0,1,idx) = -par_(1)*Zlags_(2,0,idx)+par_(5);
      out(0,2,idx) = -Zlags_(1,0,idx)*par_(1)+Zlags_(0,0,idx);
      out(1,0,idx) =  par_(1)*Zlags_(2,0,idx)-par_(5);
      out(1,1,idx) = Zlags_(2,0,idx);
      out(1,2,idx) =  Zlags_(1,0,idx)+Zlags_(0,0,idx)*par_(1);
      out(2,0,idx) = -2.0*Zlags_(0,0,idx)*( 2.0*Zlags_(2,0,idx)+1.0)/par_(2);
      out(2,1,idx) = -2.0*Zlags_(1,0,idx)*( 2.0*Zlags_(2,0,idx)+1.0)/par_(2);
      out(2,2,idx) = -( 2.0*pow(Zlags_(0,0,idx),2.0)+2.0*pow(Zlags_(1,0,idx),2.0)+1.0)/par_(2);
    }
  }
  else if (k == 1)
  {
    // Derivatives wrt state variables with delay tau
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(0,1,idx) = sin(par_(6)*( par_(7)+par_(5)))*par_(3);
      out(0,2,idx) = 0.0;
      out(1,0,idx) = -sin(par_(6)*( par_(7)+par_(5)))*par_(3);
      out(1,1,idx) = par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(1,2,idx) = 0.0;
      out(2,0,idx) = 0.0;
      out(2,1,idx) = 0.0;
      out(2,2,idx) = 0.0;
    }
  }
}


//
// This function computes the Jacobian of the vector field
// with respect to the j-th parameter.
//

static inline void __jacp(KNArray3D<double>& out, const KNArray1D<double>& time, size_t k, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_)
{
  if (k == 0)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = 0.0;
      out(1,0,idx) = 0.0;
      out(2,0,idx) = 0.0;
    }
  }
  else if (k == 1)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = -Zlags_(1,0,idx)*Zlags_(2,0,idx);
      out(1,0,idx) = Zlags_(0,0,idx)*Zlags_(2,0,idx);
      out(2,0,idx) = 0.0;
    }
  }
  else if (k == 2)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = 0.0;
      out(1,0,idx) = 0.0;
      out(2,0,idx) = ( ( 2.0*Zlags_(2,0,idx)+1.0)*( pow(Zlags_(0,0,idx),2.0)+pow(Zlags_(1,0,idx),2.0))-par_(4)+Zlags_(2,0,idx))/pow(par_(2),2.0);
    }
  }
  else if (k == 3)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) =  Zlags_(1,1,idx)*sin(par_(6)*( par_(7)+par_(5)))+Zlags_(0,1,idx)*cos(par_(6)*( par_(7)+par_(5)));
      out(1,0,idx) = -Zlags_(0,1,idx)*sin(par_(6)*( par_(7)+par_(5)))+Zlags_(1,1,idx)*cos(par_(6)*( par_(7)+par_(5)));
      out(2,0,idx) = 0.0;
    }
  }
  else if (k == 4)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = 0.0;
      out(1,0,idx) = 0.0;
      out(2,0,idx) = 1.0/(par_(2));
    }
  }
  else if (k == 5)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) =  Zlags_(1,0,idx)-Zlags_(0,1,idx)*par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)+Zlags_(1,1,idx)*par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(1,0,idx) = -Zlags_(0,0,idx)-Zlags_(1,1,idx)*par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)-Zlags_(0,1,idx)*par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(2,0,idx) = 0.0;
    }
  }
  else if (k == 6)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) =  Zlags_(1,1,idx)*par_(3)*cos(par_(6)*( par_(7)+par_(5)))*( par_(7)+par_(5))-Zlags_(0,1,idx)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)*( par_(7)+par_(5));
      out(1,0,idx) = -Zlags_(1,1,idx)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)*( par_(7)+par_(5))-Zlags_(0,1,idx)*par_(3)*cos(par_(6)*( par_(7)+par_(5)))*( par_(7)+par_(5));
      out(2,0,idx) = 0.0;
    }
  }
  else if (k == 7)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,0,idx) = -Zlags_(0,1,idx)*par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)+Zlags_(1,1,idx)*par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(1,0,idx) = -Zlags_(1,1,idx)*par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3)-Zlags_(0,1,idx)*par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
      out(2,0,idx) = 0.0;
    }
  }
}


//
// This function computes the Jacobian of the vector field
// with respect to the k-th delayed state vector and the j-th parameter.
//

static inline void __jacxp(KNArray3D<double>& out, const KNArray1D<double>& time, size_t k, size_t j, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_)
{
  if (j == 0)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 1)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = -Zlags_(2,0,idx);
        out(0,2,idx) = -Zlags_(1,0,idx);
        out(1,0,idx) = Zlags_(2,0,idx);
        out(1,1,idx) = 0.0;
        out(1,2,idx) = Zlags_(0,0,idx);
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 2)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 2.0*Zlags_(0,0,idx)*( 2.0*Zlags_(2,0,idx)+1.0)/pow(par_(2),2.0);
        out(2,1,idx) = 2.0*Zlags_(1,0,idx)*( 2.0*Zlags_(2,0,idx)+1.0)/pow(par_(2),2.0);
        out(2,2,idx) = ( 2.0*pow(Zlags_(0,0,idx),2.0)+2.0*pow(Zlags_(1,0,idx),2.0)+1.0)/pow(par_(2),2.0);
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 3)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = cos(par_(6)*( par_(7)+par_(5)));
        out(0,1,idx) = sin(par_(6)*( par_(7)+par_(5)));
        out(0,2,idx) = 0.0;
        out(1,0,idx) = -sin(par_(6)*( par_(7)+par_(5)));
        out(1,1,idx) = cos(par_(6)*( par_(7)+par_(5)));
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 4)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 5)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 1.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = -1.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = -par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3);
        out(0,1,idx) = par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
        out(0,2,idx) = 0.0;
        out(1,0,idx) = -par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
        out(1,1,idx) = -par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3);
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 6)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = -sin(par_(6)*( par_(7)+par_(5)))*par_(3)*( par_(7)+par_(5));
        out(0,1,idx) = par_(3)*cos(par_(6)*( par_(7)+par_(5)))*( par_(7)+par_(5));
        out(0,2,idx) = 0.0;
        out(1,0,idx) = -par_(3)*cos(par_(6)*( par_(7)+par_(5)))*( par_(7)+par_(5));
        out(1,1,idx) = -sin(par_(6)*( par_(7)+par_(5)))*par_(3)*( par_(7)+par_(5));
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (j == 7)
  {
    if (k == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = -par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3);
        out(0,1,idx) = par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
        out(0,2,idx) = 0.0;
        out(1,0,idx) = -par_(6)*par_(3)*cos(par_(6)*( par_(7)+par_(5)));
        out(1,1,idx) = -par_(6)*sin(par_(6)*( par_(7)+par_(5)))*par_(3);
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
}


//
// This function computes the Hessian of the vector field
// with respect to the k1-th and k2-th delayed state vectors,
// then multiplies this by the m-th column of v to obtain a matrix.
//

static inline void __hess_times_v(KNArray3D<double>& out, const KNArray1D<double>& time, size_t k1, size_t k2, int m, const KNArray3D<double>& VZlags_, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_)
{
  if (k1 == 0)
  {
    if (k2 == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = VZlags_(2,0,idx);
        out(0,1,idx) = -VZlags_(2,0,idx)*par_(1);
        out(0,2,idx) = -VZlags_(1,0,idx)*par_(1)+VZlags_(0,0,idx);
        out(1,0,idx) = VZlags_(2,0,idx)*par_(1);
        out(1,1,idx) = VZlags_(2,0,idx);
        out(1,2,idx) =  VZlags_(1,0,idx)+VZlags_(0,0,idx)*par_(1);
        out(2,0,idx) =  -4.0*Zlags_(0,0,idx)*VZlags_(2,0,idx)/par_(2)+-2.0*( 2.0*Zlags_(2,0,idx)+1.0)*VZlags_(0,0,idx)/par_(2);
        out(2,1,idx) =  -2.0*( 2.0*Zlags_(2,0,idx)+1.0)*VZlags_(1,0,idx)/par_(2)+-4.0*Zlags_(1,0,idx)*VZlags_(2,0,idx)/par_(2);
        out(2,2,idx) =  -4.0*Zlags_(0,0,idx)*VZlags_(0,0,idx)/par_(2)+-4.0*Zlags_(1,0,idx)*VZlags_(1,0,idx)/par_(2);
      }
    }
    else if (k2 == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
  else if (k1 == 1)
  {
    if (k2 == 0)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
    else if (k2 == 1)
    {
      for (size_t idx=0; idx < time.size(); ++idx)
      {
        const double t = time(idx);
        out(0,0,idx) = 0.0;
        out(0,1,idx) = 0.0;
        out(0,2,idx) = 0.0;
        out(1,0,idx) = 0.0;
        out(1,1,idx) = 0.0;
        out(1,2,idx) = 0.0;
        out(2,0,idx) = 0.0;
        out(2,1,idx) = 0.0;
        out(2,2,idx) = 0.0;
      }
    }
  }
}

//
// sys_p_deri(...)
//
// The lags are: {tau}
//
// If X(t) is the state vector at time t, then
//    Zlags_ = [ X(t) X(t-(tau)) ]
//
// The state vector:
// Are        = Zlags_(0,0,idx);
// Aim        = Zlags_(1,0,idx);
// NN         = Zlags_(2,0,idx);
//
//
void sys_p_deri(KNArray3D<double>& jac_, const KNArray1D<double>& time, const KNArray3D<double>& Zlags_, const KNArray1D<double>& par_, size_t sel,
size_t nx_, const size_t* vx_, size_t np_, const size_t* vp_, const KNArray3D<double>& v_)
{
    if (nx_ == 1 && np_ == 0)
        __jacx(jac_, time, vx_[0], Zlags_, par_);
    else if (nx_ == 0 && np_ == 1)
        __jacp(jac_, time, vp_[0], Zlags_, par_);
    else if (nx_ == 1 && np_ == 1)
        __jacxp(jac_,time, vx_[0], vp_[0], Zlags_, par_);
    else if (nx_ == 2 && np_ == 0)
        __hess_times_v(jac_, time, vx_[0], vx_[1], vx_[0], v_, Zlags_, par_);
    else
    {
        // std::cerr << "sys_deri: Requested derivative has not been implemented.\n";
        // exit(-1);
    }
}

//
// sys_p_tau(...) computes the vector of delays.
//

void sys_p_tau(KNArray2D<double>& out, const KNArray1D<double>& time, const KNArray1D<double>& par_)
{
  for (size_t idx=0; idx < time.size(); ++idx)
  {
    out(0,idx) = 0.0;
    out(1,idx) = par_(6);
  }
}

//
// sys_p_dtau(...) computes the derivatives of the delays with respect to the parameters.
//
// The delays are: tau
//

void sys_p_dtau(KNArray2D<double>& out, const KNArray1D<double>& time, const KNArray1D<double>& par_, size_t k)
{
  if (k == 0)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 1)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 2)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 3)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 4)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 5)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
  else if (k == 6)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 1.0;
    }
  }
  else if (k == 7)
  {
    for (size_t idx=0; idx < time.size(); ++idx)
    {
      const double t = time(idx);
      out(0,idx) = 0.0;
      out(1,idx) = 0.0;
    }
  }
}

void sys_stpar(KNVector& par_)
{
  par_(0) = 501;
  par_(1) = 4;
  par_(2) = 1000;
  par_(3) = 0.000386554;
  par_(4) = 0.001;
  par_(5) = -0.0002;
  par_(6) = 1000;
  par_(7) = -0.001;
}

void sys_stsol(KNVector& out, double t)
{
  out(0) = -2.4721000000000001e-01;
  out(1) = -1.8670500000000001e+00;
  out(2) = -5.6550000000000003e-03;
}

void sys_parnames( const char *out[] )
{
  out[0] = "period";
  out[1] = "alpha";
  out[2] = "TT";
  out[3] = "kappa";
  out[4] = "PP";
  out[5] = "bb";
  out[6] = "tau";
  out[7] = "omega_0";
}

}  // extern "C"
